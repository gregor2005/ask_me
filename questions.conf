q: Which two major security problems does Gary McGraw identify with legacy product integrations?
a: {{McGraw identify under the connectivity problem from the "trinity of trouble", see next question, two main problems when products are integrated into other products.
1. Exclusive reliance on host-to-host authentication with weak passwords
2. Looming data compliance implications having to do with user privacy (because unencrypted transport of data over middleware and the middleware's implementation for failover and load balancing means that queue cache files get stashed all over the place in plain text)}}
-------------------------------------
q: Which security problems does G. see with "Extensibility" and "Complexity"?
a: {{McGraw call the trend of security problems the "trinity of trouble"

- Connectivity: because every day more and more applications and workflows are connected together over the internet more security problems occurs. Things they where used offline in the past are now used online. So now the attacker can be every where and do not need physical access to the victim.

- Extensibility: is often desired because users want to add some features to persistent applications like plugins in web browsers. But these plugins can bring new security problems into the main applications. These is also a problem on operating systems because of the use of e.g. third party drivers which causes very often an "blue-screen-of-death" in Windows systems.

- Complexity: new software has more complexity and therefore most of the time more lines of code which brings often more security problem. These problem are manifested in the rule "more lines of code brings more security problems". The complexity also rises because of the before explained problems extensibility and connectivity. Also a main reason of the rising security problems are the use of unsafe programming language like C and C++ which are not protect against buffer overflows and other problems.}}
-------------------------------------
q: What are Bugs and Flaws and Defects? Explain AND give examples.
a: {{Bug: Is a implementation level software problem
 
Example: Buffer overflow is a problem where you can write over the given value and overwrite information in the memory, unsafe environment variables, ...

Defect: Are implementation and design vulnerabilities which can be lie in the software for years without a consequence.

Example: a routine which requires normally no password but under special conditions it need no password, ...

Flaw: Lies in the software code or persists in the design level. It is a problem on a much deeper level.

Example: Error-handling problems, insecure audit log design, ...

Risk: Flaws and bugs lead to risks. It is important during project planing to identify and resolve such risks. Risk calculation: risk = probability x impact

Example: any of the above problems}}
-------------------------------------
q: What are the "three pillars of software security"?
a: {{1. Risk management: Is the way to find and adherence of risk's in an application.

2. Touchpoints: Are ways to build security disciplines into a software-lifecylce.

3. Knowledge: Is experience which was learned and new experience from previous project and the current project.}}
-------------------------------------
q: Explain the figure
i: pictures/picture1.png
a: These are the touchpoints which can adapt to a software project during the project phases. For example code review tools can be used during and after the code is writen, risk analysis can be used in requirements and uses cases, architecture and design, test and test result phase.
-------------------------------------
q: Explain the five stages of the Risk Management Framework
a: {{1. Understand the business context 
In this stage it is important to fully understand the business context. The analyst must extract and describe business goals, priorities and circumstances in order to understand what kinds of software risk to care about and which business goal are paramount.

2. Identify the business and technical risks 
Here a analyst has to identify the risks which can threaten business goals in any way e.g. financial loss, damage to brand or reputation, violation of customer and many more.

3. Synthesize and prioritize the risks, producing a ranked set 
Identify and analyze risks to give them a priority help to find higher risks and list the metrics.

4. Define the risk mitigation strategy 
In the next stage ways to mitigate found risks from the previous steps have to be find.

5. Carry out required fixes and validate that they are correct
In this stage the generated mitigation strategies has to be verified and validate if they reduce the risk. The single strategies can be tested and demonstrated to see their efficiency.}}
-------------------------------------
q: What do you know about Measurement and Metrics in the RMF?
a: {{The found risks and mitigation strategies which are found during the RMF has to be reported and continuous change over time. Therefore a master list of the risk should be maintained during all stages.
Examples of metrics:

Outstanding/identified risk by priority, type, subtype

Overall risk mitigation status percentage

Risk mitigation by priority: percentage resolved, percentage outstanding, number resolved, number oustanding

Number of outstanding/identified risks by financial impact

Number of risks identified without defined mitigation by priority/type

Risk discovery rate by priority and type

Risk mitigation rate by priority and type

Number of outstanding risks by schedule impact}}
-------------------------------------
q: Explain the seven touchpoints. (100 words each). Which is the most effective? Which the least? 
a: {{1. Code review 
Artifact: Code
Here the code is analyzed with static analysis tools to find implementation bugs. It search for common vulnerabilities. With this technique not all security problems can be found but in best cases 50% of them. Further analysis has to be done to resolve more problems e.g with architectural risk analysis of the architectural design.

2. Architectural risk analysis 
Artifact: Design and specification
To analyze the architecture designers, architects and analysts have to generate clear documentations about the project and identify possible attacks.

3. Penetration testing 
Artifact: System in its environment
Here the system is tested in running state in the environment but the software architecture has also to be looked at else some interesting problems are oversight. If the software fails here it indicates hat very big problems persists. It is important that the software is tested in the penetration test not the underlying network or operating system, this is also good but did not show security problems in the application.

4. Risk-based security tests 
Artifact: Units and system
In this touchpoint tests are based on attack-patterns, risk analysis results and abuse cases should be tested. Also testing of security functionality with standard functional testing techniques should not be missed. 

5. Abuse cases 
Artifact: Requirements and use cases
Create test cases which are against the normal use cases to find some bugs and get in the mind of the attacker which want to control the software or get important information's out of the software.

6. Security requirements 
Artifact: Requirements
Security must worked into the requirements. A good requirement cover functional security and has emergent characteristics.

7. Security operations 
Artifact: Fielded system
For example a risk can be here insufficient logging to oversight an malicious behavior or attacker. Its important to fully understand the software to generate defensive techniques.}}
-------------------------------------
q: How would you establish a Software Security Group?
q: It's no good idea to took a network security person to train him has a software security person because many knowledge about software, programming language, frameworks, compilers and other information's are missing. Took a software people instead. A senior developer will be better than a starter because he has to introduce other developers and they will not trust a starter. The chosen person should learn about risk management framework to better identify risks and create mitigation strategies.
-------------------------------------
q: Can binary analysis be used to find software vulnerabilities? Why would you use this method? Would you prefer another method? 
a: Binary analysis is a way to find vulnerabilities in given binary files like an executable. It can help to find bugs when you don't have the source code. I would use this code when i haven't the source code but it's easier to find vulnerabilities when you have the source code then i would prefer other methods like code review, static analysis and others.
-------------------------------------
q: Give an example for static analysis. Which tools can be used? Give a code example and what a tool would find. Give an example for correct warning/error (in code + explanation), a false negative and a false positive. (Hint: you might want to try one tool that the book mentions)
a: {{Static analysis is a way to search vulnerabilities in the code. The first tool in this area was release in 2000 called ITS4. After the release other tools are generated like RATS, Flawfinder and SourceScope. First the tools only uses a grep similar way to find vulnerabilities. This method does not find all vulnerabilities because the releationship between the methods and classes are not checked so the tools generate tokens from the code and generate an abstract syntax tree, like the compiler, to check vulnerabilities in the releationships.
I have tested the tool flawfinder

Example:
main() { 
  char x[20]; // positive: can be overflowed 
  char y[20]; // positive: can be overflowed 
  strcpy(x, y); // positive: can write over [20] and produce a buffer overflow 
  strlcpy(x, y); // no flaw because this checks for buffer overflow 
  strcpy(x, "abc"); // false positive: because "abc" is constant and did not go over [20] 
} 

false negative: when a vulnerabilities is oversight by the analysis tool so there is still a flaw in the source code
false positive: when a vulnerabilities is found which is really no vulnerability}}
-------------------------------------
q: Explain STRIDE 
a: STRIDE is a risk analysis practice from Microsoft. A big problem is that Microsoft uses the term threat different than the literature uses it, they called their practices threat modeling instead of risk analysis. But beside that McGraw says that the idea of STRIDE is a good way.
-------------------------------------
q: What is an asset, risk, threat, vulnerability, countermeasure, safeguard, impact, ALE, SLE, ARO? 
a: {{asset: The object which should be protected, e.g. the whole system

risk: = probability x impact. The probability that an asset will suffer and an event of a given negative impact.

threat: Can use vulnerabilities to abuse the software, e.g. an attacker

vulnerability: A defect or problem in the software which an attacker can use to abuse the software

countermeasure: A way to protect the confidentiality, integrity and availability of the system

safeguard: Is a synonym for countermeasure

impact: Occurs after a vulnerability is used

Risk Calculation

ALE: annualized loss expectancy or financial loss

SLE: single loss expectancy

ARO: annualized rate of occurrence

ALE = SLE x ARO}}
-------------------------------------
q: What are the three critical steps in architectural risk analysis approach? Explain them in detail (100 words each). Give examples.
a: {{1. Attack resistance analysis 
This is a way to list problems of a software project in a checklist-like style. It is used in the STRIDE approach. The idea is to identify general flaws from a knowledge base, map attack patterns which are possible from the found flaws, identify risk in the architecture, understand and demonstrate the viability of the attacks. These way is good to find known problems but but to find new attacks.

2. Ambiguity analysis 
These discipline require two or more analysts with good security skills. In this Analysis new risk should be discovered. The two analysts generate their own lists of risks and then in a whiteboard brainstorming session and discuss their findings.

3. Weakness analysis
Is a way to understanding the impact of the external software dependencies. Because software uses middle-ware like JavaEE and are not build up from the ground, weak libraries can be uses in these middle-ware to bunch a hole in the written software.}}
-------------------------------------
q: Which tools do you know that can be used for pentesting? Explain how they work, what they find and what they do not find. 
a: {{Cenzic
This tool uses browser shunts to intercept transactions. It is possible to test and find vulnerabilities in web applications

Holodeck
It is a tool to find broken environment, it uses hostile conditions to find system failures

Nessus, OpenVAS
These tools test network devices and operating systems, over the network, to find known vulnerabilities.
For all tools it is important to know them very good to get the best out of it and so the pentest profit from the results. All of these tools are no single solution, there is no single solution.}}
-------------------------------------
q: When would you use pentesting?
a: Pentesting are linked to tests and test results and feedback from the field in the touchpoints. As McGraw wrote in the last sentences in chapter 6, pentesting should be the last check before code goes live.
-------------------------------------

 
